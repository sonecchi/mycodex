#!/usr/bin/env python3
"""
æœ€æ–°ã® Codex ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‹ã‚‰ã€Œ5æ™‚é–“åˆ¶é™ã€ã¨ã€Œé€±é–“åˆ¶é™ã€ã®
ä½¿ç”¨çŠ¶æ³ã‚’ã‚µã‚¯ãƒƒã¨è¡¨ç¤ºã™ã‚‹ã‚¹ã‚¯ãƒªãƒ—ãƒˆã ãœ ğŸ˜

å‡ºåŠ›ã‚¤ãƒ¡ãƒ¼ã‚¸:

  5h limit: 84% used (resets 16:29)
  Weekly limit: 60% used (resets 12:34 on 25 Oct)

ãƒ‡ãƒ¼ã‚¿ã®å–ã‚Šæ–¹:
- CODEX_HOME (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: ~/.codex)/sessions/**/rollout-*.jsonl ã®ã†ã¡ã€
  ã€Œä¸€ç•ªæ–°ã—ã„ rollout JSONL ãƒ•ã‚¡ã‚¤ãƒ«ã€ã‚’æ¢ã™
- ãã®ä¸­ã®æœ€å¾Œã® `token_count` ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¦‹ã¤ã‘ã¦ã€
  `rate_limits.primary` / `rate_limits.secondary` ã‚’èª­ã‚€
- TUI ã®è¡¨ç¤ºã«å¯„ã›ãŸãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§ã€
  ãƒªã‚»ãƒƒãƒˆæ™‚åˆ»ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã‚¿ã‚¤ãƒ ã«å¤‰æ›ã—ã¦è¡¨ç¤ºã™ã‚‹
- ãƒªã‚»ãƒƒãƒˆæ™‚åˆ»ã®å–å¾—ã¯ã©ã¡ã‚‰ã«ã‚‚å¯¾å¿œ:
    - æ–°å½¢å¼: `resets_at` (UNIX ã‚¨ãƒãƒƒã‚¯ç§’)
    - æ—§å½¢å¼: ã‚¤ãƒ™ãƒ³ãƒˆæ™‚åˆ» + `resets_in_seconds`

çµ‚äº†ã‚³ãƒ¼ãƒ‰ (é›‘ã«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¦‹ã‚‹ç”¨):
- 0: æ­£å¸¸ã«çµæœã‚’è¡¨ç¤ºã§ããŸ
- 1: ã‚»ãƒƒã‚·ãƒ§ãƒ³ or rollout ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸ
- 2: æœ€æ–°ã® rollout ã« token_count ã‚¤ãƒ™ãƒ³ãƒˆãŒãªã‹ã£ãŸ
- 3: æœ€å¾Œã® token_count ã« rate_limits ãŒãªã‹ã£ãŸ
- 4: primary / secondary ã®ã©ã¡ã‚‰ã®ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚‚ãªã‹ã£ãŸ
- 5: å€¤ã®å‹ãŒãŠã‹ã—ãã¦ãƒ‘ãƒ¼ã‚¹ã§ããªã‹ã£ãŸ
"""
from __future__ import annotations

import base64
import json
import os
import sys
from glob import glob
from pathlib import Path
from datetime import datetime, timedelta, timezone


def _to_local(dt: datetime) -> datetime:
    if dt.tzinfo is None:
        # ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³æƒ…å ±ãŒãªã„å ´åˆã¯ UTC ã¨ã¿ãªã—ã¦ã‹ã‚‰ãƒ­ãƒ¼ã‚«ãƒ«ã«å¤‰æ›ã™ã‚‹
        dt = dt.replace(tzinfo=timezone.utc)
    return dt.astimezone()


def _parse_rollout_ts(ts: str) -> datetime | None:
    # rollout ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—æ–‡å­—åˆ— (ä¾‹: 2025-08-09T15:51:14.294Z) ã‚’ datetime ã«å¤‰æ›
    try:
        if ts.endswith("Z"):
            ts = ts[:-1] + "+00:00"
        return datetime.fromisoformat(ts)
    except Exception:
        return None


def _format_reset_timestamp(reset_local: datetime, captured_local: datetime) -> str:
    time_str = reset_local.strftime("%H:%M")
    same_day = reset_local.date() == captured_local.date()
    if same_day:
        return time_str
    # æ—¥ä»˜éƒ¨åˆ†ã ã‘ãƒ­ã‚±ãƒ¼ãƒ«ä¾å­˜ã«ãªã‚‰ãªã„ & å…ˆé ­ã‚¼ãƒ­ã‚’é¿ã‘ãŸã„ã®ã§ã¡ã‚‡ã£ã¨å·¥å¤«
    try:
        day_mon = reset_local.strftime("%-d %b")
    except Exception:
        day_mon = reset_local.strftime("%d %b").lstrip("0")
    return f"{time_str} on {day_mon}"


def codex_home() -> Path:
    # CODEX_HOME ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚Œã°ãã‚Œã‚’å„ªå…ˆã€ãªã‘ã‚Œã° ~/.codex ã‚’è¦‹ã‚‹
    p = os.environ.get("CODEX_HOME")
    if p:
        return Path(p).expanduser()
    return Path.home() / ".codex"


def _title_case(s: str) -> str:
    # "plus" -> "Plus" ãã‚‰ã„ã®è»½ã„ç”¨é€”ã‚’æƒ³å®š
    if not s:
        return ""
    return s[:1].upper() + s[1:].lower()


def _decode_jwt_payload(jwt_token: str) -> dict | None:
    parts = jwt_token.split(".")
    if len(parts) < 2:
        return None

    payload_b64 = parts[1]
    # base64url ã¯ padding ãŒçœç•¥ã•ã‚Œã¦ã„ã‚‹ã“ã¨ãŒã‚ã‚‹ã®ã§è£œã†
    padded = payload_b64 + ("=" * (-len(payload_b64) % 4))
    try:
        raw = base64.urlsafe_b64decode(padded)
    except Exception:
        return None

    try:
        obj = json.loads(raw.decode("utf-8", errors="replace"))
    except Exception:
        return None

    return obj if isinstance(obj, dict) else None


def account_line(home: Path) -> str | None:
    # ChatGPT ãƒ­ã‚°ã‚¤ãƒ³æ™‚ã® id_token ã‹ã‚‰ email / plan ã‚’æ‹¾ã£ã¦ 1 è¡Œã«ã™ã‚‹ã€‚
    # å–ã‚Œãªã„å ´åˆã¯ None ã‚’è¿”ã—ã¦å‡ºåŠ›ã—ãªã„ã€‚
    auth_path = home / "auth.json"
    if not auth_path.exists():
        return None

    try:
        data = json.loads(auth_path.read_text(encoding="utf-8"))
    except Exception:
        return None

    tokens = data.get("tokens")
    if not isinstance(tokens, dict):
        return None

    id_token = tokens.get("id_token")
    if not isinstance(id_token, str) or not id_token:
        return None

    claims = _decode_jwt_payload(id_token)
    if claims is None:
        return None

    email = claims.get("email")
    if not isinstance(email, str) or not email:
        return None

    plan_type: str | None = None
    auth_claim = claims.get("https://api.openai.com/auth")
    if isinstance(auth_claim, dict):
        raw_plan = auth_claim.get("chatgpt_plan_type")
        if isinstance(raw_plan, str) and raw_plan:
            plan_type = raw_plan

    plan = _title_case(plan_type) if plan_type else "Unknown"
    return f"Account: {email} ({plan})"


def find_latest_rollout(home: Path) -> Path | None:
    # sessions é…ä¸‹ã® rollout-*.jsonl ã®ã†ã¡ã€ä¸€ç•ªæ–°ã—ã„ã‚‚ã®ã‚’æ‹¾ã†
    pattern = str((home / "sessions" / "**" / "rollout-*.jsonl").resolve())
    files = glob(pattern, recursive=True)
    if not files:
        return None
    try:
        return max((Path(f) for f in files), key=lambda p: p.stat().st_mtime)
    except Exception:
        return None


def iter_jsonl(path: Path):
    # JSONL ã‚’1è¡Œãšã¤ç´ ç›´ã«èª­ã‚€ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿
    with path.open("r", encoding="utf-8", errors="replace") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                yield json.loads(line)
            except Exception:
                continue


def last_token_count(path: Path) -> tuple[dict, datetime] | tuple[None, None]:
    # rollout ã®ä¸­ã‹ã‚‰ã€Œæœ€å¾Œã® token_count ã‚¤ãƒ™ãƒ³ãƒˆã€ã¨ãã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’è¿”ã™
    last: dict | None = None
    last_ts: datetime | None = None
    for obj in iter_jsonl(path):
        ts_raw = obj.get("timestamp")
        ev_ts = _parse_rollout_ts(ts_raw) if isinstance(ts_raw, str) else None
        if obj.get("type") != "event_msg":
            continue
        payload = obj.get("payload") or {}
        if payload.get("type") != "token_count":
            continue
        last = payload
        last_ts = ev_ts
    return (last, last_ts) if last is not None and last_ts is not None else (None, None)


def main() -> int:
    # ã“ã“ãŒãƒ¡ã‚¤ãƒ³å‡¦ç†ã€‚ç•°å¸¸ã‚±ãƒ¼ã‚¹ã¯çµ‚äº†ã‚³ãƒ¼ãƒ‰ã§ã–ã£ãã‚Šåˆ¤å®šã§ãã‚‹ã‚ˆã†ã«ã—ã¦ã‚‹ã€‚
    home = codex_home()
    latest = find_latest_rollout(home)
    if latest is None or not latest.exists():
        print("no session rollouts found (CODEX_HOME/sessions)", file=sys.stderr)
        return 1

    payload, ev_ts = last_token_count(latest)
    if payload is None or ev_ts is None:
        print("no token_count events found in latest rollout", file=sys.stderr)
        return 2

    rl = payload.get("rate_limits")
    if rl is None:
        print("no rate_limits in last token_count event", file=sys.stderr)
        return 3

    primary = rl.get("primary") if isinstance(rl, dict) else None
    secondary = rl.get("secondary") if isinstance(rl, dict) else None
    if not isinstance(primary, dict) and not isinstance(secondary, dict):
        print("no primary/secondary windows present", file=sys.stderr)
        return 4

    captured_local = _to_local(ev_ts)

    def line_for(label: str, win: dict | None) -> str | None:
        # 1ã¤ã®ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ (5h / Weekly) ã«ã¤ã„ã¦ã€1è¡Œåˆ†ã®è¡¨ç¤ºãƒ†ã‚­ã‚¹ãƒˆã‚’ä½œã‚‹
        if not isinstance(win, dict):
            return None
        try:
            used = float(win.get("used_percent"))
        except Exception:
            return None
        resets_str = None

        # æ–°ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ: çµ¶å¯¾æ™‚é–“ (ã‚¨ãƒãƒƒã‚¯ç§’) ã§ã®ãƒªã‚»ãƒƒãƒˆæ™‚åˆ»
        resets_at = win.get("resets_at")
        reset_dt: datetime | None = None
        if isinstance(resets_at, (int, float)):
            try:
                reset_dt = datetime.fromtimestamp(float(resets_at), tz=timezone.utc)
            except Exception:
                reset_dt = None

        # æ—§ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ: ã‚¤ãƒ™ãƒ³ãƒˆæ™‚åˆ»ã‹ã‚‰ã®ç›¸å¯¾ç§’æ•°
        if reset_dt is None:
            resets_in = win.get("resets_in_seconds")
            if isinstance(resets_in, (int, float)):
                reset_dt = ev_ts + timedelta(seconds=float(resets_in))

        if reset_dt is not None:
            reset_local = _to_local(reset_dt)
            resets_str = _format_reset_timestamp(reset_local, captured_local)

        base = f"{label} limit: {used:.0f}% used"
        return f"{base} (resets {resets_str})" if resets_str else base

    # primary å´ã¯ window_minutes ã‚’è¦‹ã¦ã€5h ä»¥å¤–ã®çŸ­ã„çª“ã«ã‚‚ãã‚Œã£ã½ã„è¡¨ç¤ºã‚’ä»˜ã‘ã‚‹
    def label_for_primary(win: dict | None) -> str:
        if not isinstance(win, dict):
            return "5h"
        minutes = win.get("window_minutes")
        try:
            m = int(minutes)
        except Exception:
            return "5h"
        # TUI å´ã® get_limits_duration ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’ã–ã£ãã‚Šå†ç¾
        MINUTES_PER_HOUR = 60
        MINUTES_PER_DAY = 24 * MINUTES_PER_HOUR
        ROUNDING_BIAS = 3
        if m <= MINUTES_PER_DAY + ROUNDING_BIAS:
            hours = max(1, (m + ROUNDING_BIAS) // MINUTES_PER_HOUR)
            return f"{hours}h"
        return "5h"

    lines: list[str] = []
    if isinstance(primary, dict):
        lines.append(line_for(label_for_primary(primary), primary))
    if isinstance(secondary, dict):
        lines.append(line_for("Weekly", secondary))

    # None ã‚’æƒé™¤ã—ã¦ã‹ã‚‰ã€ç´ ç›´ã«1è¡Œãšã¤å‡ºåŠ›
    lines = [ln for ln in lines if ln]
    if not lines:
        return 5
    acct = account_line(home)
    if acct:
        lines.append(acct)
    for ln in lines:
        print(ln)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
