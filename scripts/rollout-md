#!/usr/bin/env python3
"""
Codex ã® rollout-*.jsonl ã‹ã‚‰ã€
ãã­ã£ã¡ãŒèª­ã¿ã‚„ã™ã„ Markdown ãƒ­ã‚°ã‚’åãå‡ºã™ã‚¹ã‚¯ãƒªãƒ—ãƒˆã ãœ ğŸ˜

ã–ã£ãã‚Šã‚„ã£ã¦ã‚‹ã“ã¨:
- rollout JSONL (1è¡Œ1ã‚¤ãƒ™ãƒ³ãƒˆ) ã‚’æ™‚ç³»åˆ—ã§ãªã‚ã‚‹
- user / assistant ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ã€
  ãƒ„ãƒ¼ãƒ«å‘¼ã³å‡ºã—(function_call)ã¨ãã®çµæœ(function_call_output)ã ã‘ã‚’æ‹¾ã†
- ãã‚Œãã‚Œã‚’ Markdown ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³:
    # ãã­ã£ã¡ğŸ¤”
    # ãƒ„ãƒ¼ãƒ«å®Ÿè¡ŒğŸ”§
    ## å®Ÿè¡ŒçµæœğŸ“¤
    # ä¿ºã£ã¡ğŸ§ 
  ã¨ã„ã†è¦‹å‡ºã—ã§ä¸¦ã¹ã¦ã„ã

ä½¿ã„æ–¹:
- å¼•æ•°ãªã—: CODEX_HOME (~/.codex) é…ä¸‹ã‹ã‚‰ã€Œä¸€ç•ªæ–°ã—ã„ rollout-*.jsonlã€ã‚’è‡ªå‹•ã§é¸ã¶
    scripts/rollout-md

- ç‰¹å®šã® JSONL ã‚’æŒ‡å®š:
    scripts/rollout-md -i /path/to/rollout-2025-12-27T....jsonl

- æœ€è¿‘ã®ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ãƒ¢ãƒ¼ãƒ‰:
    scripts/rollout-md -n 10

  ä¸Šä½ N ä»¶ã® rollout-*.jsonl ã‚’æ–°ã—ã„é †ã«è¡¨ç¤ºã—ã¦ã€
  ã€Œã©ã‚Œã‚’ .md ã«ã™ã‚‹ï¼Ÿã€ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ã€
  1ä»¶ç›®ã‚’ä½¿ã£ãŸã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒãƒ³ãƒ‰ + ãã®çµæœã® Markdown ã‚‚ç¶šã‘ã¦å‡ºåŠ›ã™ã‚‹ã€‚

å‡ºåŠ›å…ˆ:
- æ¨™æº–å‡ºåŠ›ã« Markdown ã‚’ãã®ã¾ã¾åãã®ã§ã€
  ãƒ•ã‚¡ã‚¤ãƒ«ã«ã—ãŸã‘ã‚Œã°ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã§ OK:
    scripts/rollout-md > session-log.md
"""

from __future__ import annotations

import argparse
import json
import os
import sys
from dataclasses import dataclass
from datetime import datetime, timezone
from glob import glob
from pathlib import Path
from typing import Iterable


def codex_home() -> Path:
    """CODEX_HOME ãŒã‚ã‚Œã°ãã‚Œã‚’å„ªå…ˆã€ãªã‘ã‚Œã° ~/.codex ã‚’ä½¿ã†ã€‚"""
    p = os.environ.get("CODEX_HOME")
    if p:
        return Path(p).expanduser()
    return Path.home() / ".codex"


def find_latest_rollout(home: Path) -> Path | None:
    """sessions é…ä¸‹ã® rollout-*.jsonl ã®ã†ã¡ã€ä¸€ç•ªæ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¿”ã™ã€‚"""
    files = find_all_rollouts(home)
    if not files:
        return None
    try:
        return max(files, key=lambda p: p.stat().st_mtime)
    except Exception:
        return None


def find_all_rollouts(home: Path) -> list[Path]:
    """sessions é…ä¸‹ã® rollout-*.jsonl ã‚’ã™ã¹ã¦åˆ—æŒ™ã™ã‚‹ã€‚"""
    pattern = str((home / "sessions" / "**" / "rollout-*.jsonl").resolve())
    files = glob(pattern, recursive=True)
    return [Path(f) for f in files]


def iter_jsonl(path: Path) -> Iterable[dict]:
    """JSONL ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ 1 è¡Œãšã¤ dict ã¨ã—ã¦èª­ã‚€ç°¡å˜ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã€‚"""
    with path.open("r", encoding="utf-8", errors="replace") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                obj = json.loads(line)
            except Exception:
                continue
            if isinstance(obj, dict):
                yield obj


def _parse_timestamp(ts: str | None) -> datetime | None:
    """rollout ã® timestamp (ä¾‹: 2025-12-27T03:40:03.432Z) ã‚’ datetime ã«å¤‰æ›ã€‚"""
    if not isinstance(ts, str):
        return None
    try:
        if ts.endswith("Z"):
            ts = ts[:-1] + "+00:00"
        return datetime.fromisoformat(ts)
    except Exception:
        return None


@dataclass
class MdChunk:
    ts: datetime | None
    kind: str  # "user" | "assistant" | "tool_call" | "tool_output"
    heading: str
    body: str


def _content_to_text(content: list[dict]) -> str:
    """response_item.payload.content ã®é…åˆ—ã‹ã‚‰ãƒ†ã‚­ã‚¹ãƒˆéƒ¨åˆ†ã‚’ã„ã„æ„Ÿã˜ã«çµåˆã™ã‚‹ã€‚"""
    parts: list[str] = []
    for item in content:
        if not isinstance(item, dict):
            continue
        text = item.get("text")
        if isinstance(text, str):
            parts.append(text)
    return "\n\n".join(parts).rstrip()


def _format_tool_call(payload: dict) -> str:
    """function_call ã®ä¸­èº«ã‚’ Markdown ç”¨ã®æ–‡å­—åˆ—ã«æ•´å½¢ã™ã‚‹ã€‚"""
    name = payload.get("name") or "unknown_tool"
    args_raw = payload.get("arguments")

    formatted_args = ""
    if isinstance(args_raw, str):
        # JSON ã£ã½ã‘ã‚Œã°ãƒ‘ãƒ¼ã‚¹ã‚’è©¦ã¿ã¦ã€ã„ã„æ„Ÿã˜ã«æ•´å½¢ã—ã¦ã‚ã’ã‚‹
        try:
            parsed = json.loads(args_raw)
            formatted_args = json.dumps(parsed, ensure_ascii=False, indent=2)
        except Exception:
            formatted_args = args_raw
    elif isinstance(args_raw, dict):
        formatted_args = json.dumps(args_raw, ensure_ascii=False, indent=2)

    lines = [f"- ãƒ„ãƒ¼ãƒ«å: `{name}`"]
    call_id = payload.get("call_id")
    if isinstance(call_id, str):
        lines.append(f"- call_id: `{call_id}`")
    if formatted_args:
        lines.append("")
        lines.append("```json")
        lines.append(formatted_args)
        lines.append("```")
    return "\n".join(lines).rstrip()


def _format_tool_output(payload: dict, tool_name: str | None) -> str:
    """function_call_output ã® output ã‚’ Markdown ç”¨æ–‡å­—åˆ—ã«æ•´å½¢ã™ã‚‹ã€‚"""
    output = payload.get("output")
    if not isinstance(output, str):
        return ""

    lines: list[str] = []
    if tool_name:
        lines.append(f"- ãƒ„ãƒ¼ãƒ«å: `{tool_name}`")
        lines.append("")
    lines.append("```text")
    lines.append(output.rstrip())
    lines.append("```")
    return "\n".join(lines).rstrip()


def extract_md_chunks(path: Path) -> list[MdChunk]:
    """
    rollout-*.jsonl ã‹ã‚‰ã€Markdown ã«ã—ãŸã„è¦ç´ ã ã‘ã‚’ MdChunk ã®ãƒªã‚¹ãƒˆã¨ã—ã¦æŠœãå‡ºã™ã€‚

    - user ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ => # ãã­ã£ã¡ğŸ¤”
    - assistant ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ => # ä¿ºã£ã¡ğŸ§ 
    - function_call => # ãƒ„ãƒ¼ãƒ«å®Ÿè¡ŒğŸ”§
    - function_call_output => ## å®Ÿè¡ŒçµæœğŸ“¤
    """
    chunks: list[MdChunk] = []
    # call_id -> tool name ã‚’è¦šãˆã¦ãŠã„ã¦ã€output å´ã§ã‚‚ãƒ„ãƒ¼ãƒ«åã‚’ä»˜ã‘ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹
    tool_names: dict[str, str] = {}

    for obj in iter_jsonl(path):
        ts = _parse_timestamp(obj.get("timestamp"))
        if obj.get("type") != "response_item":
            continue
        payload = obj.get("payload")
        if not isinstance(payload, dict):
            continue

        p_type = payload.get("type")
        if p_type == "message":
            role = payload.get("role")
            content = payload.get("content")
            if not isinstance(content, list):
                continue
            text = _content_to_text(content)
            if not text:
                continue
            if role == "user":
                chunks.append(
                    MdChunk(
                        ts=ts,
                        kind="user",
                        heading="# ãã­ã£ã¡ğŸ¤”",
                        body=text,
                    )
                )
            elif role == "assistant":
                chunks.append(
                    MdChunk(
                        ts=ts,
                        kind="assistant",
                        heading="# ä¿ºã£ã¡ğŸ§ ",
                        body=text,
                    )
                )
        elif p_type == "function_call":
            call_id = payload.get("call_id")
            name = payload.get("name")
            if isinstance(call_id, str) and isinstance(name, str):
                tool_names[call_id] = name
            body = _format_tool_call(payload)
            if not body:
                continue
            chunks.append(
                MdChunk(
                    ts=ts,
                    kind="tool_call",
                    heading="# ãƒ„ãƒ¼ãƒ«å®Ÿè¡ŒğŸ”§",
                    body=body,
                )
            )
        elif p_type == "function_call_output":
            call_id = payload.get("call_id")
            tool_name = tool_names.get(call_id) if isinstance(call_id, str) else None
            body = _format_tool_output(payload, tool_name)
            if not body:
                continue
            chunks.append(
                MdChunk(
                    ts=ts,
                    kind="tool_output",
                    heading="## å®Ÿè¡ŒçµæœğŸ“¤",
                    body=body,
                )
            )

    # å¿µã®ãŸã‚ timestamp ã§ã‚½ãƒ¼ãƒˆï¼ˆã ã„ãŸã„ãƒ•ã‚¡ã‚¤ãƒ«é †ã ã‘ã©ã€æ•´ãˆã¦ãŠãï¼‰
    chunks.sort(key=lambda c: (c.ts or datetime.fromtimestamp(0, tz=timezone.utc)))
    return chunks


def render_markdown(chunks: list[MdChunk], source: Path) -> str:
    """MdChunk ã®ãƒªã‚¹ãƒˆã‚’ 1 ã¤ã® Markdown æ–‡å­—åˆ—ã«ã¾ã¨ã‚ã‚‹ã€‚"""
    lines: list[str] = []

    # å…ˆé ­ã«ã¡ã‚‡ã£ã¨ã ã‘ãƒ¡ã‚¿æƒ…å ±ã‚’ä»˜ã‘ã‚‹
    lines.append(f"# Codex ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ­ã‚° from `{source.name}`")
    lines.append("")
    lines.append("> ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ `scripts/rollout-md` ã§ç”Ÿæˆã•ã‚ŒãŸ Markdown ãƒ­ã‚°ã ã‚ˆã€‚")
    lines.append("")

    for chunk in chunks:
        lines.append(chunk.heading)
        lines.append("")
        lines.append(chunk.body)
        lines.append("")

    # æœ«å°¾ã®ç©ºè¡Œã¯ 1ã¤ã«æƒãˆã¦ãŠã
    while lines and not lines[-1].strip():
        lines.pop()
    lines.append("")
    return "\n".join(lines)


def list_mode(num: int) -> int:
    """
    æœ€è¿‘ã® rollout-*.jsonl ã‚’ num ä»¶ã ã‘ä¸€è¦§è¡¨ç¤ºã—ã¦ã€
    1ä»¶ç›®ã‚’ä½¿ã£ãŸ Markdown å‡ºåŠ›ã®ã‚µãƒ³ãƒ—ãƒ«ã‚‚è¦‹ã›ã‚‹ãƒ¢ãƒ¼ãƒ‰ã€‚
    """
    if num <= 0:
        print("-n ã«ã¯ 1 ä»¥ä¸Šã‚’æŒ‡å®šã—ã¦ãã‚Œã‚ˆãªï¼", file=sys.stderr)
        return 1

    home = codex_home()
    files = find_all_rollouts(home)
    if not files:
        print("rollout JSONL ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã‚ˆâ€¦ (CODEX_HOME/sessions ã‚’ç¢ºèªã—ã¦ã¿ã¦)", file=sys.stderr)
        return 1

    # å…ƒã® find | sort -r ã¨åŒã˜ãã€ã€Œæ–°ã—ã„ã‚‚ã®ã‹ã‚‰é †ã€ã«ä¸¦ã¹ãŸã„ã®ã§
    # æœ€çµ‚æ›´æ–°æ™‚åˆ»ã§ã‚½ãƒ¼ãƒˆã—ã¦ä¸Šä½ num ä»¶ã ã‘å‡ºã™ã€‚
    try:
        files_sorted = sorted(files, key=lambda p: p.stat().st_mtime, reverse=True)
    except Exception:
        files_sorted = files

    target = files_sorted[:num]

    print(f"æœ€è¿‘ã® rollout-*.jsonl ä¸Šä½ {len(target)} ä»¶ (æ–°ã—ã„é †):")
    for idx, p in enumerate(target, start=1):
        print(f"{idx:2d}: {p}")

    # ä¸€å¿œ 1 ä»¶ã‚‚ãªã„ã‚±ãƒ¼ã‚¹ã¯ã•ã£ãå¼¾ã„ã¦ã„ã‚‹ãŒã€å¿µã®ãŸã‚
    if not target:
        return 1

    chosen = target[0]
    print()
    print("ã©ã‚Œã‚’.mdã«ã™ã‚‹ï¼Ÿ")
    sample_cmd = f"scripts/rollout-md -i {chosen} > session-log.md"
    print(sample_cmd)
    print()

    # ä¸Šè¨˜ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ãŸã¨ãã«å‡ºã‚‹ã§ã‚ã‚ã† Markdown ã‚‚ãã®ã¾ã¾å‡ºåŠ›
    chunks = extract_md_chunks(chosen)
    if not chunks:
        print("é¸ã‚“ã ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ Markdown ã«ã§ãã‚‹ã‚¤ãƒ™ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸâ€¦", file=sys.stderr)
        return 2

    md = render_markdown(chunks, chosen)
    try:
        sys.stdout.write(md)
    except BrokenPipeError:
        # head ãªã©ã§ãƒ‘ã‚¤ãƒ—ã‚’é€”ä¸­ã§åˆ‡ã‚‰ã‚ŒãŸã¨ãã‚‚é™ã‹ã«çµ‚äº†
        return 0
    return 0


def main(argv: list[str] | None = None) -> int:
    parser = argparse.ArgumentParser(
        description="Codex rollout-*.jsonl ã‚’ Markdown ãƒ­ã‚°ã¨ã—ã¦æ•´å½¢ã—ã¦å‡ºåŠ›ã™ã‚‹ã‚„ã¤ã€‚",
    )
    parser.add_argument(
        "-i",
        "--input",
        type=str,
        help="å…¥åŠ›ã«ä½¿ã† rollout-*.jsonl ã®ãƒ‘ã‚¹ã€‚çœç•¥æ™‚ã¯ç›´è¿‘ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è‡ªå‹•æ¤œå‡ºã™ã‚‹ã€‚",
    )
    parser.add_argument(
        "-n",
        "--num",
        type=int,
        help="æœ€è¿‘ã® rollout-*.jsonl ã‚’ N ä»¶ä¸€è¦§è¡¨ç¤ºã—ã¦ã€ã‚µãƒ³ãƒ—ãƒ«ã® Markdown å‡ºåŠ›ã‚‚ä½µã›ã¦è¡¨ç¤ºã™ã‚‹ãƒ¢ãƒ¼ãƒ‰ã€‚",
    )

    args = parser.parse_args(argv)

    # -n ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹ã¨ãã¯ä¸€è¦§ãƒ¢ãƒ¼ãƒ‰ã€‚-i ã¨åŒæ™‚æŒ‡å®šã¯åˆ†ã‹ã‚Šã¥ã‚‰ã„ã®ã§å¼¾ãã€‚
    if args.num is not None:
        if args.input:
            print("-n ã¨ -i ã¯åŒæ™‚ã«ã¯ä½¿ãˆãªã„ã‚ˆï¼ã©ã¡ã‚‰ã‹ç‰‡æ–¹ã«ã—ã¦ãã‚Œã€‚", file=sys.stderr)
            return 1
        return list_mode(args.num)

    if args.input:
        path = Path(args.input).expanduser()
    else:
        home = codex_home()
        path = find_latest_rollout(home) or Path("")

    if not path or not path.exists():
        print("rollout JSONL ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã‚ˆâ€¦ (CODEX_HOME/sessions ã‚’ç¢ºèªã—ã¦ã¿ã¦)", file=sys.stderr)
        return 1

    chunks = extract_md_chunks(path)
    if not chunks:
        print("Markdown ã«ã§ãã‚‹ã‚¤ãƒ™ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸâ€¦", file=sys.stderr)
        return 2

    md = render_markdown(chunks, path)
    try:
        sys.stdout.write(md)
    except BrokenPipeError:
        # head ãªã©ã§é€”ä¸­ã§ãƒ‘ã‚¤ãƒ—ã‚’åˆ‡ã‚‰ã‚ŒãŸå ´åˆã‚‚é™ã‹ã«çµ‚ã‚ã‚‹
        return 0
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
