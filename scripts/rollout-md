#!/usr/bin/env python3
"""
Codex ã® rollout-*.jsonl ã‹ã‚‰ã€
ãã­ã£ã¡ãŒèª­ã¿ã‚„ã™ã„ Markdown ãƒ­ã‚°ã‚’åãå‡ºã™ã‚¹ã‚¯ãƒªãƒ—ãƒˆã ãœ ğŸ˜

ã–ã£ãã‚Šã‚„ã£ã¦ã‚‹ã“ã¨:
- rollout JSONL (1è¡Œ1ã‚¤ãƒ™ãƒ³ãƒˆ) ã‚’æ™‚ç³»åˆ—ã§ãªã‚ã‚‹
- user / assistant ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ã€
  ãƒ„ãƒ¼ãƒ«å‘¼ã³å‡ºã—(function_call)ã¨ãã®çµæœ(function_call_output)ã ã‘ã‚’æ‹¾ã†
- ãã‚Œãã‚Œã‚’ Markdown ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³:
    # ãã­ã£ã¡ğŸ¤”
    # ãƒ„ãƒ¼ãƒ«å®Ÿè¡ŒğŸ”§
    ## å®Ÿè¡ŒçµæœğŸ“¤
    # ä¿ºã£ã¡ğŸ§ 
  ã¨ã„ã†è¦‹å‡ºã—ã§ä¸¦ã¹ã¦ã„ã

ä½¿ã„æ–¹:
- å¼•æ•°ãªã—: CODEX_HOME (~/.codex) é…ä¸‹ã‹ã‚‰æœ€è¿‘ã® rollout-*.jsonl ã‚’ 10 ä»¶ä¸€è¦§è¡¨ç¤º
    rollout-md

- ç‰¹å®šã® JSONL ã‚’æŒ‡å®šã—ã¦ Markdown ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜:
    rollout-md -i /path/to/rollout-2025-12-27T....jsonl -o mydocs/worklog/xxx.md

- å…¥åŠ› JSONL ã‚’çœç•¥ã—ã¦ç›´è¿‘ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ Markdown ã«ä¿å­˜:
    rollout-md -o mydocs/worklog/xxx.md

- æœ€è¿‘ã®ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ãƒ¢ãƒ¼ãƒ‰ï¼ˆä»¶æ•°æŒ‡å®šï¼‰:
    rollout-md -n 10

  ä¸Šä½ N ä»¶ã® rollout-*.jsonl ã‚’æ–°ã—ã„é †ã«è¡¨ç¤ºã—ã¦ã€
  ã€Œã©ã‚Œã‚’ .md ã«ã™ã‚‹ï¼Ÿã€ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ã€
  1ä»¶ç›®ã‚’ä½¿ã£ãŸã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒãƒ³ãƒ‰ã‚‚ç¶šã‘ã¦å‡ºåŠ›ã™ã‚‹ã€‚

å‡ºåŠ›å…ˆ:
- -o ã§æŒ‡å®šã—ãŸãƒ‘ã‚¹ã« Markdown ã‚’æ›¸ãå‡ºã™ã€‚
"""

from __future__ import annotations

import argparse
import json
import os
import sys
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone
from glob import glob
from pathlib import Path
from typing import Iterable
import re


def codex_home() -> Path:
    """CODEX_HOME ãŒã‚ã‚Œã°ãã‚Œã‚’å„ªå…ˆã€ãªã‘ã‚Œã° ~/.codex ã‚’ä½¿ã†ã€‚"""
    p = os.environ.get("CODEX_HOME")
    if p:
        return Path(p).expanduser()
    return Path.home() / ".codex"


def find_latest_rollout(home: Path) -> Path | None:
    """sessions é…ä¸‹ã® rollout-*.jsonl ã®ã†ã¡ã€ä¸€ç•ªæ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¿”ã™ã€‚"""
    files = find_all_rollouts(home)
    if not files:
        return None
    try:
        return max(files, key=lambda p: p.stat().st_mtime)
    except Exception:
        return None


def find_all_rollouts(home: Path) -> list[Path]:
    """sessions é…ä¸‹ã® rollout-*.jsonl ã‚’ã™ã¹ã¦åˆ—æŒ™ã™ã‚‹ã€‚"""
    pattern = str((home / "sessions" / "**" / "rollout-*.jsonl").resolve())
    files = glob(pattern, recursive=True)
    return [Path(f) for f in files]


def iter_jsonl(path: Path) -> Iterable[dict]:
    """JSONL ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ 1 è¡Œãšã¤ dict ã¨ã—ã¦èª­ã‚€ç°¡å˜ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã€‚"""
    with path.open("r", encoding="utf-8", errors="replace") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                obj = json.loads(line)
            except Exception:
                continue
            if isinstance(obj, dict):
                yield obj


def _parse_timestamp(ts: str | None) -> datetime | None:
    """rollout ã® timestamp (ä¾‹: 2025-12-27T03:40:03.432Z) ã‚’ datetime ã«å¤‰æ›ã€‚"""
    if not isinstance(ts, str):
        return None
    try:
        if ts.endswith("Z"):
            ts = ts[:-1] + "+00:00"
        return datetime.fromisoformat(ts)
    except Exception:
        return None


def _escape_triple_backticks(text: str) -> str:
    """
    Markdown å…¨ä½“ãŒå£Šã‚Œãªã„ã‚ˆã†ã«ã€ç´ ã®ã€Œ```ã€ã‚’ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã—ã¦ãŠãã€‚

    è¡Œé ­ã« ``` ãŒã‚ã‚‹ã¨ã‚³ãƒ¼ãƒ‰ãƒ•ã‚§ãƒ³ã‚¹ã¨ã—ã¦è§£é‡ˆã•ã‚Œã¦ã€
    é–‹å§‹ãƒ»çµ‚äº†ã®ãƒšã‚¢ãŒãšã‚Œã‚‹ã¨å…¨ä½“ã®è¡¨ç¤ºãŒå´©ã‚Œã‚‹ã“ã¨ãŒã‚ã‚‹ã®ã§ã€
    ãƒ­ã‚°ä¸Šã§ã¯ \\``` ã®ã‚ˆã†ã« 1 æ–‡å­—ã ã‘é€ƒãŒã—ã¦ãŠãä½œæˆ¦ã€‚
    """
    return text.replace("```", "\\```")


@dataclass
class MdChunk:
    ts: datetime | None
    kind: str  # "user" | "assistant" | "tool_call" | "tool_output" | "reasoning"
    heading: str
    body: str


def _format_ts_jst(ts: datetime | None) -> str:
    """datetime ã‚’ JST ã® 'YYYY-MM-DD HH:MM' å½¢å¼ã«æ•´å½¢ã™ã‚‹ã€‚"""
    if ts is None:
        return ""
    try:
        jst = timezone(timedelta(hours=9))
        local = ts.astimezone(jst)
    except Exception:
        return ""
    return local.strftime("%Y-%m-%d %H:%M")


def _content_to_text(content: list[dict]) -> str:
    """response_item.payload.content ã®é…åˆ—ã‹ã‚‰ãƒ†ã‚­ã‚¹ãƒˆéƒ¨åˆ†ã‚’ã„ã„æ„Ÿã˜ã«çµåˆã™ã‚‹ã€‚"""
    parts: list[str] = []
    for item in content:
        if not isinstance(item, dict):
            continue
        text = item.get("text")
        if isinstance(text, str):
            parts.append(text)
    merged = "\n\n".join(parts).rstrip()
    return _escape_triple_backticks(merged)


def _summary_to_text(summary: list[dict]) -> str:
    """reasoning.payload.summary ã®é…åˆ—ã‹ã‚‰ãƒ†ã‚­ã‚¹ãƒˆã‚’çµåˆã—ã¦ Markdown ç”¨ã«æ•´å½¢ã™ã‚‹ã€‚"""
    parts: list[str] = []
    for item in summary:
        if not isinstance(item, dict):
            continue
        text = item.get("text")
        if isinstance(text, str):
            parts.append(text)
    merged = "\n\n".join(parts).rstrip()
    return _escape_triple_backticks(merged)


def _format_tool_call(payload: dict) -> str:
    """function_call ã®ä¸­èº«ã‚’ Markdown ç”¨ã®æ–‡å­—åˆ—ã«æ•´å½¢ã™ã‚‹ã€‚"""
    name = payload.get("name") or "unknown_tool"
    args_raw = payload.get("arguments")

    formatted_args = ""
    if isinstance(args_raw, str):
        # JSON ã£ã½ã‘ã‚Œã°ãƒ‘ãƒ¼ã‚¹ã‚’è©¦ã¿ã¦ã€ã„ã„æ„Ÿã˜ã«æ•´å½¢ã—ã¦ã‚ã’ã‚‹
        try:
            parsed = json.loads(args_raw)
            formatted_args = json.dumps(parsed, ensure_ascii=False, indent=2)
        except Exception:
            formatted_args = args_raw
    elif isinstance(args_raw, dict):
        formatted_args = json.dumps(args_raw, ensure_ascii=False, indent=2)

    if formatted_args:
        formatted_args = _escape_triple_backticks(formatted_args)

    lines = [f"- ãƒ„ãƒ¼ãƒ«å: `{name}`"]
    call_id = payload.get("call_id")
    if isinstance(call_id, str):
        lines.append(f"- call_id: `{call_id}`")
    if formatted_args:
        lines.append("")
        lines.append("```json")
        lines.append(formatted_args)
        lines.append("```")
    return "\n".join(lines).rstrip()


def _format_tool_output(payload: dict, tool_name: str | None) -> str:
    """function_call_output ã® output ã‚’ Markdown ç”¨æ–‡å­—åˆ—ã«æ•´å½¢ã™ã‚‹ã€‚"""
    output = payload.get("output")
    if not isinstance(output, str):
        return ""

    output = _escape_triple_backticks(output)

    lines: list[str] = []
    if tool_name:
        lines.append(f"- ãƒ„ãƒ¼ãƒ«å: `{tool_name}`")
        lines.append("")
    lines.append("```text")
    lines.append(output.rstrip())
    lines.append("```")
    return "\n".join(lines).rstrip()


def extract_md_chunks(path: Path) -> list[MdChunk]:
    """
    rollout-*.jsonl ã‹ã‚‰ã€Markdown ã«ã—ãŸã„è¦ç´ ã ã‘ã‚’ MdChunk ã®ãƒªã‚¹ãƒˆã¨ã—ã¦æŠœãå‡ºã™ã€‚

    - user ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ => # ãã­ã£ã¡ğŸ¤”
    - assistant ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ => # ä¿ºã£ã¡ğŸ§ 
    - function_call => # ãƒ„ãƒ¼ãƒ«å®Ÿè¡ŒğŸ”§
    - function_call_output => ## å®Ÿè¡ŒçµæœğŸ“¤
    """
    chunks: list[MdChunk] = []
    # call_id -> tool name ã‚’è¦šãˆã¦ãŠã„ã¦ã€output å´ã§ã‚‚ãƒ„ãƒ¼ãƒ«åã‚’ä»˜ã‘ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹
    tool_names: dict[str, str] = {}

    for obj in iter_jsonl(path):
        ts = _parse_timestamp(obj.get("timestamp"))
        if obj.get("type") != "response_item":
            continue
        payload = obj.get("payload")
        if not isinstance(payload, dict):
            continue

        p_type = payload.get("type")
        if p_type == "message":
            role = payload.get("role")
            content = payload.get("content")
            if not isinstance(content, list):
                continue
            text = _content_to_text(content)
            if not text:
                continue
            if role == "user":
                ts_str = _format_ts_jst(ts)
                heading = "# ãã­ã£ã¡ğŸ¤”"
                if ts_str:
                    heading = f"{heading} ({ts_str})"
                chunks.append(
                    MdChunk(
                        ts=ts,
                        kind="user",
                        heading=heading,
                        body=text,
                    )
                )
            elif role == "assistant":
                ts_str = _format_ts_jst(ts)
                heading = "# ä¿ºã£ã¡ğŸ¤–"
                if ts_str:
                    heading = f"{heading} ({ts_str})"
                chunks.append(
                    MdChunk(
                        ts=ts,
                        kind="assistant",
                        heading=heading,
                        body=text,
                    )
                )
        elif p_type == "reasoning":
            summary = payload.get("summary")
            if not isinstance(summary, list):
                continue
            text = _summary_to_text(summary)
            if not text:
                continue
            chunks.append(
                MdChunk(
                    ts=ts,
                    kind="reasoning",
                    heading="# æ€è€ƒğŸ§ ",
                    body=text,
                )
            )
        elif p_type == "function_call":
            call_id = payload.get("call_id")
            name = payload.get("name")
            if isinstance(call_id, str) and isinstance(name, str):
                tool_names[call_id] = name
            body = _format_tool_call(payload)
            if not body:
                continue
            chunks.append(
                MdChunk(
                    ts=ts,
                    kind="tool_call",
                    heading="# ãƒ„ãƒ¼ãƒ«å®Ÿè¡ŒğŸ”§",
                    body=body,
                )
            )
        elif p_type == "function_call_output":
            call_id = payload.get("call_id")
            tool_name = tool_names.get(call_id) if isinstance(call_id, str) else None
            body = _format_tool_output(payload, tool_name)
            if not body:
                continue
            chunks.append(
                MdChunk(
                    ts=ts,
                    kind="tool_output",
                    heading="## å®Ÿè¡ŒçµæœğŸ“¤",
                    body=body,
                )
            )

    # å¿µã®ãŸã‚ timestamp ã§ã‚½ãƒ¼ãƒˆï¼ˆã ã„ãŸã„ãƒ•ã‚¡ã‚¤ãƒ«é †ã ã‘ã©ã€æ•´ãˆã¦ãŠãï¼‰
    chunks.sort(key=lambda c: (c.ts or datetime.fromtimestamp(0, tz=timezone.utc)))
    return chunks


def _find_cwd_from_rollout(path: Path) -> str | None:
    """rollout JSONL å†…ã® session_meta / turn_context ãªã©ã‹ã‚‰ cwd ã‚’æ¢ã™ã€‚"""
    for obj in iter_jsonl(path):
        if not isinstance(obj, dict):
            continue
        payload = obj.get("payload")
        if isinstance(payload, dict):
            cwd = payload.get("cwd")
            if isinstance(cwd, str):
                return cwd
    return None


def render_markdown(chunks: list[MdChunk], source: Path) -> str:
    """MdChunk ã®ãƒªã‚¹ãƒˆã‚’ 1 ã¤ã® Markdown æ–‡å­—åˆ—ã«ã¾ã¨ã‚ã‚‹ã€‚"""
    lines: list[str] = []

    # å…ˆé ­ã«ã€ãƒ•ã‚¡ã‚¤ãƒ«åã¨ cwd ã‚’ä»˜ã‘ã‚‹
    out_name = _default_md_path_for_rollout(source).name
    lines.append(f"# ä¼šè©±ãƒ­ã‚° {out_name}")
    lines.append("")
    cwd = _find_cwd_from_rollout(source) or os.getcwd()
    lines.append(f"\"cwd\":\"{cwd}\"")
    lines.append("")

    for chunk in chunks:
        lines.append(chunk.heading)
        lines.append("")
        lines.append(chunk.body)
        lines.append("")

    # æœ«å°¾ã®ç©ºè¡Œã¯ 1ã¤ã«æƒãˆã¦ãŠã
    while lines and not lines[-1].strip():
        lines.pop()
    lines.append("")
    return "\n".join(lines)


def _session_id_from_stem(stem: str) -> str:
    """rollout-*.jsonl ã® stem ã‹ã‚‰ã‚»ãƒƒã‚·ãƒ§ãƒ³IDã£ã½ã„éƒ¨åˆ†ã‚’æŠœãå‡ºã™ã€‚å¤±æ•—ã—ãŸã‚‰ stem å…¨ä½“ã€‚"""
    if stem.startswith("rollout-"):
        rest = stem[len("rollout-") :]
        m_session = re.match(
            r"[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}-[0-9]{2}-[0-9]{2}-(.+)", rest
        )
        if m_session:
            return m_session.group(1)
    return stem


def _default_md_path_for_rollout(path: Path) -> Path:
    """rollout JSONL ã‹ã‚‰ã€mydocs/worklog/YYMMDD_<session-id>.md ã®ãƒ‘ã‚¹ã‚’çµ„ã¿ç«‹ã¦ã‚‹ã€‚"""
    try:
        ts = datetime.fromtimestamp(path.stat().st_mtime)
    except Exception:
        ts = datetime.now()
    y = ts.year % 100
    m = ts.month
    d = ts.day

    session_id = _session_id_from_stem(path.stem)
    return Path("mydocs") / "worklog" / f"{y:02d}{m:02d}{d:02d}_{session_id}.md"


def list_mode(num: int) -> int:
    """
    æœ€è¿‘ã® rollout-*.jsonl ã‚’ num ä»¶ã ã‘ä¸€è¦§è¡¨ç¤ºã—ã¦ã€
    1ä»¶ç›®ã‚’ä½¿ã£ãŸ Markdown å‡ºåŠ›ã®ã‚µãƒ³ãƒ—ãƒ«ã‚‚è¦‹ã›ã‚‹ãƒ¢ãƒ¼ãƒ‰ã€‚
    """
    if num <= 0:
        print("-n ã«ã¯ 1 ä»¥ä¸Šã‚’æŒ‡å®šã—ã¦ãã‚Œã‚ˆãªï¼", file=sys.stderr)
        return 1

    home = codex_home()
    files = find_all_rollouts(home)
    if not files:
        print("rollout JSONL ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã‚ˆâ€¦ (CODEX_HOME/sessions ã‚’ç¢ºèªã—ã¦ã¿ã¦)", file=sys.stderr)
        return 1

    # å…ƒã® find | sort -r ã¨åŒã˜ãã€ã€Œæ–°ã—ã„ã‚‚ã®ã‹ã‚‰é †ã€ã«ä¸¦ã¹ãŸã„ã®ã§
    # æœ€çµ‚æ›´æ–°æ™‚åˆ»ã§ã‚½ãƒ¼ãƒˆã—ã¦ä¸Šä½ num ä»¶ã ã‘å‡ºã™ã€‚
    try:
        files_sorted = sorted(files, key=lambda p: p.stat().st_mtime, reverse=True)
    except Exception:
        files_sorted = files

    target = files_sorted[:num]

    home_path = str(Path.home())

    print(f"æœ€è¿‘ã® rollout-*.jsonl ä¸Šä½ {len(target)} ä»¶ (æ–°ã—ã„é †):")
    for idx, p in enumerate(target, start=1):
        display = str(p)
        if display.startswith(home_path):
            display = "~" + display[len(home_path) :]
        print(f"{idx}: {display}")

    # ä¸€å¿œ 1 ä»¶ã‚‚ãªã„ã‚±ãƒ¼ã‚¹ã¯ã•ã£ãå¼¾ã„ã¦ã„ã‚‹ãŒã€å¿µã®ãŸã‚
    if not target:
        return 1

    chosen = target[0]
    print()
    print("ã©ã‚Œã‚’.mdã«ã™ã‚‹ï¼Ÿ")
    # 260101_<session-id>.md å½¢å¼ã§ã€æ—¥ä»˜ + ã‚»ãƒƒã‚·ãƒ§ãƒ³IDãƒ™ãƒ¼ã‚¹ã®åå‰ã‚’ææ¡ˆã™ã‚‹
    suggested_md = str(_default_md_path_for_rollout(chosen))
    # /home/sonecchi/ ã‚’ ~ ã«å¤‰æ›´ã—ã¦å‡ºåŠ›
    chosen_str = str(chosen)
    if chosen_str.startswith(home_path):
        chosen_str = "~" + chosen_str[len(home_path) :]
    sample_cmd = f"rollout-md -i {chosen_str} -o {suggested_md}"
    print(sample_cmd)
    print()
    # -n ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã“ã“ã¾ã§ã€‚å®Ÿéš›ã® .md å‡ºåŠ›ã¯ã€
    # ãã­ã£ã¡ãŒä¸Šã®ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒãƒ³ãƒ‰ã‚’å©ã„ãŸã¨ãã ã‘è¡Œã†ã€‚
    return 0


def main(argv: list[str] | None = None) -> int:
    parser = argparse.ArgumentParser(
        description="Codex rollout-*.jsonl ã‚’ Markdown ãƒ­ã‚°ã¨ã—ã¦æ•´å½¢ã—ã¦å‡ºåŠ›ã™ã‚‹ã‚„ã¤ã€‚",
    )
    parser.add_argument(
        "-i",
        "--input",
        type=str,
        help="å…¥åŠ›ã«ä½¿ã† rollout-*.jsonl ã®ãƒ‘ã‚¹ã€‚çœç•¥æ™‚ã¯ç›´è¿‘ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è‡ªå‹•æ¤œå‡ºã™ã‚‹ã€‚",
    )
    parser.add_argument(
        "-o",
        "--output",
        type=str,
        nargs="?",
        const="",
        help="å‡ºåŠ›å…ˆã® Markdown ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã€‚çœç•¥æ™‚ã¯ä¸€è¦§ãƒ¢ãƒ¼ãƒ‰(-n, ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ10ä»¶)ã€‚",
    )
    parser.add_argument(
        "-n",
        "--num",
        type=int,
        help="æœ€è¿‘ã® rollout-*.jsonl ã‚’ N ä»¶ä¸€è¦§è¡¨ç¤ºã—ã¦ã€ã‚µãƒ³ãƒ—ãƒ«ã® Markdown å‡ºåŠ›ã‚‚ä½µã›ã¦è¡¨ç¤ºã™ã‚‹ãƒ¢ãƒ¼ãƒ‰ã€‚",
    )
    parser.add_argument(
        "-c",
        "--continue",
        dest="continue_mode",
        action="store_true",
        help="æœ€æ–°ã® rollout-*.jsonl ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ‘ã‚¹(mydocs/worklog/YYMMDD_<session-id>.md)ã«å‡ºåŠ›ã™ã‚‹ãƒ¢ãƒ¼ãƒ‰ã€‚",
    )

    args = parser.parse_args(argv)

    # -c ã¯å˜ç‹¬ã§ä½¿ã†ãƒ¢ãƒ¼ãƒ‰
    if args.continue_mode:
        if args.num is not None or args.output or args.input:
            print("-c ã¯å˜ç‹¬ã§ä½¿ã£ã¦ãã‚Œï¼ä»–ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¨ã¯ä¸€ç·’ã«ä½¿ãˆãªã„ã‚“ã ã€‚", file=sys.stderr)
            return 1

        home = codex_home()
        path = find_latest_rollout(home) or Path("")
        if not path or not path.exists():
            print("rollout JSONL ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã‚ˆâ€¦ (CODEX_HOME/sessions ã‚’ç¢ºèªã—ã¦ã¿ã¦)", file=sys.stderr)
            return 1

        chunks = extract_md_chunks(path)
        if not chunks:
            print("Markdown ã«ã§ãã‚‹ã‚¤ãƒ™ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸâ€¦", file=sys.stderr)
            return 2

        md = render_markdown(chunks, path)
        out_path = _default_md_path_for_rollout(path)
        try:
            out_path.parent.mkdir(parents=True, exist_ok=True)
        except Exception:
            pass

        try:
            out_path.write_text(md, encoding="utf-8")
        except Exception as exc:
            print(f"Markdown ã®æ›¸ãè¾¼ã¿ã«å¤±æ•—ã—ã¡ã‚ƒã£ãŸâ€¦: {exc}", file=sys.stderr)
            return 1

        print(".mdã§ããŸã‚ˆï¼ğŸ˜†firefoxğŸ¦Šã§é–‹ã„ã¦ã¿ã¦ã­ï¼âœ¨")
        print(f"firefox {out_path} &")
        return 0

    # -o ãŒãªã„ or å‡ºåŠ›å…ˆæœªæŒ‡å®šã®ã¨ãã¯ä¸€è¦§ãƒ¢ãƒ¼ãƒ‰ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ 10 ä»¶ï¼‰
    if not args.output:
        if args.num is not None and args.input:
            print("-n ã¨ -i ã¯åŒæ™‚ã«ã¯ä½¿ãˆãªã„ã‚ˆï¼ã©ã¡ã‚‰ã‹ç‰‡æ–¹ã«ã—ã¦ãã‚Œã€‚", file=sys.stderr)
            return 1
        num = args.num if args.num is not None else 10
        return list_mode(num)

    # ã“ã“ã‹ã‚‰ã¯ -o ã§å‡ºåŠ›å…ˆãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹ã¨ãã®å‡¦ç†
    if args.num is not None:
        print("-n ã¯ä¸€è¦§ãƒ¢ãƒ¼ãƒ‰å°‚ç”¨ã ã‚ˆï¼-o ã¨ä¸€ç·’ã«ã¯ä½¿ãˆãªã„ã‚ˆã€‚", file=sys.stderr)
        return 1

    if args.input:
        path = Path(args.input).expanduser()
    else:
        home = codex_home()
        path = find_latest_rollout(home) or Path("")

    if not path or not path.exists():
        print("rollout JSONL ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã‚ˆâ€¦ (CODEX_HOME/sessions ã‚’ç¢ºèªã—ã¦ã¿ã¦)", file=sys.stderr)
        return 1

    chunks = extract_md_chunks(path)
    if not chunks:
        print("Markdown ã«ã§ãã‚‹ã‚¤ãƒ™ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸâ€¦", file=sys.stderr)
        return 2

    md = render_markdown(chunks, path)

    out_path = Path(args.output).expanduser()
    try:
        out_path.parent.mkdir(parents=True, exist_ok=True)
    except Exception:
        pass

    try:
        out_path.write_text(md, encoding="utf-8")
    except Exception as exc:
        print(f"Markdown ã®æ›¸ãè¾¼ã¿ã«å¤±æ•—ã—ã¡ã‚ƒã£ãŸâ€¦: {exc}", file=sys.stderr)
        return 1

    print(".mdã§ããŸã‚ˆï¼ğŸ˜†firefoxğŸ¦Šã§é–‹ã„ã¦ã¿ã¦ã­ï¼âœ¨")
    print(f"firefox {args.output} &")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
